# main.py ‚Äî RedditStatusCheckerBot (Reports –∏–∑ Reddit, —Å—Ç–∞—Ç—É—Å –∏–∑ Reddit Status)
# –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ aiogram v3. –ü–æ–¥—Ö–æ–¥–∏—Ç –∏ –¥–ª—è Render Web Service (—Å health-—Å–µ—Ä–≤–µ—Ä–æ–º).

import os
import io
import math
import asyncio
import datetime as dt

import httpx

import matplotlib
matplotlib.use("Agg")  # –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –±—ç–∫–µ–Ω–¥ –¥–ª—è —Ö–æ—Å—Ç–∏–Ω–≥–∞ –±–µ–∑ –¥–∏—Å–ø–ª–µ—è
import matplotlib.pyplot as plt

from aiohttp import web

from aiogram import Bot, Dispatcher, types
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.types.input_file import BufferedInputFile

import time

REDDIT_CLIENT_ID = os.getenv("REDDIT_CLIENT_ID")
REDDIT_CLIENT_SECRET = os.getenv("REDDIT_CLIENT_SECRET")

# ==== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è ====
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set")

USER_AGENT = os.getenv("USER_AGENT", "RedditStatusCheckerBot/1.1 (+https://example.com)")
ENABLE_HTTP = os.getenv("ENABLE_HTTP", "1") == "1"  # –¥–ª—è Render Web Service –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∫–ª—é—á–µ–Ω–æ
PORT = int(os.getenv("PORT", "10000"))

# ==== –ò—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö ====
STATUS_URL = "https://www.redditstatus.com/api/v2/summary.json"  # –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
SEARCH_URL = "https://www.reddit.com/search.json"                # –ø—É–±–ª–∏—á–Ω—ã–π –ø–æ–∏—Å–∫ (–±–µ–∑ OAuth)

# ==== –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è (RU/EN) ====
LANGS = {
    "ru": {
        "status_ok": "‚úÖ Reddit —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ.",
        "status_down": "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã –Ω–∞ Reddit!",
        "title": "Reports (24—á)",
        "x_label": "–í—Ä–µ–º—è (UTC)",
        "y_label": "Reports",
        "reports": "Reports (–∑–∞ —á–∞—Å)",
        "no_data": "–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö / No data yet.",
        "web": "Web version",
        "date": "–î–∞—Ç–∞ (UTC)",
        "help": (
            "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–∫–∞–∑—ã–≤–∞—é —Å—Ç–∞—Ç—É—Å Reddit –∏ –≥—Ä–∞—Ñ–∏–∫ 'Reports'.\n\n"
            "–ö–æ–º–∞–Ω–¥—ã:\n"
            "/status ‚Äî —Å—Ç–∞—Ç—É—Å + –≥—Ä–∞—Ñ–∏–∫ Reports (24—á)\n"
            "/graph ‚Äî —Ç–æ–ª—å–∫–æ –≥—Ä–∞—Ñ–∏–∫ Reports (24—á)"
        ),
    },
    "en": {
        "status_ok": "‚úÖ Reddit is operating normally.",
        "status_down": "‚ö†Ô∏è Reddit seems to be having issues!",
        "title": "Reports (24h)",
        "x_label": "Time (UTC)",
        "y_label": "Reports",
        "reports": "Reports (last hour)",
        "no_data": "No data yet.",
        "web": "Web version",
        "date": "Date (UTC)",
        "help": (
            "üëã Hi! I show Reddit status and a 'Reports' graph.\n\n"
            "Commands:\n"
            "/status ‚Äî status + Reports graph (24h)\n"
            "/graph ‚Äî Reports graph (24h) only"
        ),
    },
}

# ==== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ ====
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()


def _now_utc() -> dt.datetime:
    return dt.datetime.now(dt.timezone.utc)


def _lang(msg: types.Message) -> str:
    lc = (msg.from_user.language_code or "").lower()
    return "ru" if lc.startswith("ru") else "en"


# ---------- –û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å Reddit ----------
async def fetch_status_summary() -> dict:
    async with httpx.AsyncClient(timeout=15, headers={"User-Agent": USER_AGENT}) as c:
        r = await c.get(STATUS_URL)
        r.raise_for_status()
        return r.json()


# ---------- Reports –∏–∑ Reddit-–ø–æ–∏—Å–∫–∞ ----------
def _bucket_by_hour(children: list) -> dict:
    """–ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ—Å—Ç—ã –ø–æ —á–∞—Å—É (UTC)."""
    buckets = {}
    for it in children:
        d = it.get("data", {})
        ts = d.get("created_utc")
        if ts is None:
            continue
        t = dt.datetime.fromtimestamp(ts, tz=dt.timezone.utc).replace(minute=0, second=0, microsecond=0)
        buckets[t] = buckets.get(t, 0) + 1
    return buckets


async def fetch_reports_series_24h() -> list[tuple[dt.datetime, int]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç [(t_hour, count), ...] –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
    –ø–æ –∑–∞–ø—Ä–æ—Å—É '(reddit down) OR (is reddit down)'.
    """
    headers = {"User-Agent": USER_AGENT, "Accept": "application/json"}
    params = {
        "q": "(reddit down) OR (is reddit down)",
        "sort": "new",
        "t": "day",
        "limit": 250,        # –º–∞–∫—Å–∏–º—É–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–∞ –≤—ã–¥–∞—á—É
        "restrict_sr": "0",
    }
    try:
        async with httpx.AsyncClient(timeout=20, headers=headers) as c:
            r = await c.get(SEARCH_URL, params=params)
            if r.status_code != 200:
                return []
            data = r.json() or {}
            children = data.get("data", {}).get("children", [])
    except Exception:
        return []

    buckets = _bucket_by_hour(children)
    now = _now_utc().replace(minute=0, second=0, microsecond=0)
    start = now - dt.timedelta(hours=24)

    series = []
    cur = start
    while cur <= now:
        series.append((cur, buckets.get(cur, 0)))
        cur += dt.timedelta(hours=1)
    return series


# ---------- –†–µ–Ω–¥–µ—Ä –≥—Ä–∞—Ñ–∏–∫–∞ ----------
def plot_reports(points: list[tuple[dt.datetime, int]], lang: str = "en") -> io.BytesIO | None:
    if not points:
        return None
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]

    plt.figure(figsize=(6, 3))
    plt.plot(xs, ys, marker="o")
    plt.title(LANGS[lang]["title"])
    plt.xlabel(LANGS[lang]["x_label"])
    plt.ylabel(LANGS[lang]["y_label"])
    plt.grid(True, alpha=0.3)

    buf = io.BytesIO()
    plt.savefig(buf, format="png", bbox_inches="tight")
    buf.seek(0)
    plt.close()
    return buf


# ---------- –ö–æ–º–∞–Ω–¥—ã ----------
@dp.message(Command(commands=["start", "help"]))
async def start_cmd(msg: types.Message):
    lang = _lang(msg)
    await msg.answer(LANGS[lang]["help"])


@dp.message(Command(commands=["status"]))
async def status_cmd(msg: types.Message):
    lang = _lang(msg)

    # 1) —Å—Ç–∞—Ç—É—Å Reddit (–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π)
    data = await fetch_status_summary()
    description = data["status"]["description"]
    ok = "Operational" in description
_token_cache = {"access_token": None, "exp": 0}

async def get_reddit_token() -> str | None:
    if not (REDDIT_CLIENT_ID and REDDIT_CLIENT_SECRET):
        return None
    now = time.time()
    if _token_cache["access_token"] and now < _token_cache["exp"] - 60:
        return _token_cache["access_token"]
    auth = httpx.BasicAuth(REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET)
    data = {"grant_type": "client_credentials"}
    headers = {"User-Agent": USER_AGENT}
    async with httpx.AsyncClient(timeout=15) as c:
        r = await c.post("https://www.reddit.com/api/v1/access_token",
                         auth=auth, data=data, headers=headers)
        r.raise_for_status()
        j = r.json()
    _token_cache["access_token"] = j["access_token"]
    _token_cache["exp"] = now + j.get("expires_in", 3600)
    return _token_cache["access_token"]

    # 2) —Å–µ—Ä–∏—è Reports –∑–∞ 24—á
    async def fetch_reports_series_24h() -> list[tuple[dt.datetime, int]]:
    """
    –ü—ã—Ç–∞–µ–º—Å—è —á–µ—Ä–µ–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π OAuth (–Ω–∞–¥—ë–∂–Ω–æ). –ï—Å–ª–∏ –∫–ª—é—á–µ–π –Ω–µ—Ç ‚Äî –ø–∞–¥–∞–µ–º
    –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ –ø—É–±–ª–∏—á–Ω—ã–π search.json –∫–∞–∫ —Ä–∞–Ω—å—à–µ.
    """
    now_ts = int(_now_utc().timestamp())
    hour_ago = now_ts - 24 * 3600

    token = await get_reddit_token()
    headers = {"User-Agent": USER_AGENT, "Accept": "application/json"}

    items = []
    try:
        if token:
            headers["Authorization"] = f"bearer {token}"
            # cloudsearch-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å: —Ñ–∏–ª—å—Ç—Ä –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            params = {
                "q": f"(reddit down) OR (is reddit down) AND timestamp:{hour_ago}..{now_ts}",
                "syntax": "cloudsearch",
                "sort": "new",
                "limit": 100,
                "type": "link",
            }
            url = "https://oauth.reddit.com/search"
            async with httpx.AsyncClient(timeout=20, headers=headers) as c:
                after = None
                for _ in range(5):  # –¥–æ 5 —Å—Ç—Ä–∞–Ω–∏—Ü
                    pr = dict(params)
                    if after:
                        pr["after"] = after
                    r = await c.get(url, params=pr)
                    if r.status_code != 200:
                        break
                    d = r.json().get("data", {})
                    kids = d.get("children", [])
                    items.extend(kids)
                    after = d.get("after")
                    if not after:
                        break
        else:
            # fallback: –ø—É–±–ª–∏—á–Ω—ã–π search.json (–º–æ–∂–µ—Ç 429/403)
            params = {
                "q": "(reddit down) OR (is reddit down)",
                "sort": "new",
                "t": "day",
                "limit": 250,
                "restrict_sr": "0",
                "raw_json": 1,
            }
            async with httpx.AsyncClient(timeout=20, headers=headers) as c:
                r = await c.get(SEARCH_URL, params=params)
                if r.status_code == 200:
                    items = (r.json() or {}).get("data", {}).get("children", [])
    except Exception:
        items = []

    # —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å –ø–æ —á–∞—Å–∞–º
    buckets = _bucket_by_hour(items)
    now = _now_utc().replace(minute=0, second=0, microsecond=0)
    start = now - dt.timedelta(hours=24)
    series = []
    cur = start
    while cur <= now:
        series.append((cur, buckets.get(cur, 0)))
        cur += dt.timedelta(hours=1)
    return series



@dp.message(Command(commands=["graph"]))
async def graph_cmd(msg: types.Message):
    lang = _lang(msg)
    series = await fetch_reports_series_24h()
    buf = plot_reports(series, lang)
    if not buf:
        await msg.answer(LANGS[lang]["no_data"])
        return
    await msg.answer_photo(BufferedInputFile(buf.getvalue(), filename="reports_24h.png"))


# ---------- –ú–∏–Ω–∏ HTTP-—Å–µ—Ä–≤–µ—Ä (–¥–ª—è Render Web Service) ----------
async def health(request):
    return web.Response(text="ok")

async def run_http_server():
    app = web.Application()
    app.router.add_get("/", health)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", PORT)
    await site.start()
    print(f"HTTP health server on :{PORT}")


# ---------- –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ ----------
async def main():
    if ENABLE_HTTP:
        asyncio.create_task(run_http_server())
    print("Bot polling starting...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
